{"posts":[{"title":"Ansible(2) - Ansible inventory configuration and connectivity testing Ansible配置主机和连接测试教程","text":"1. open the inventory file with your favorite editor and modify it1sudo vi /etc/ansible/hosts add servers likes below: 123[servers]server1 ansible_host=192.168.1.100 ansible_ssh_user=test_user ansible_ssh_pass=password ansible_ssh_extra_args='-o StrictHostKeyChecking=no'server2 ansible_host=192.168.1.101 ansible_ssh_user=test_user ansible_ssh_pass=password ansible_ssh_extra_args='-o StrictHostKeyChecking=no' 2. verify the inventory 1ansible-inventory --list -y 3. test connectivity by using a Ansible ping1ansible all -m ping 4. run a testing command from control node to host nodes1ansible all -a &quot;df -h&quot; 参数说明 args: all: all servers -a: using ad-hoc commands df: disk free -h: –human-readable : print sizes in power of 1024","link":"/ansible-2-inventory-configuration-and-connectivity-testing.html"},{"title":"Ansible(1) - How to install Red Hat Ansible on ubuntu, 如何在Ubuntu上安装red hat ansible","text":"1.add Ansible repository to your system 添加Ansible仓库到系统1$ sudo apt-add-repository ppa:ansible/ansible Then, press [ENTER] to proceed, output likes below screenshoot shows: 2.Run the update command before installing to update existing packages1$ sudo apt-get update 3.install the Ansible package1$ sudo apt-get install ansible -y 4.You can check if you’re on the latest version of Ansible by running the version command1$ ansible --version","link":"/how-to-install-red-hat-ansible-on-ubuntu.html"},{"title":"GIT如何回退到某个历史提交版本","text":"在日常使用git版本控制器的过程中，难免会出现不小心push推送提交到远程服务器仓库中，这时就需要后悔药来回退到上一次提交的版本或者指定的版本。本文使用Git的GUI界面管理工具 TortoiseGit 为例，并在步骤6提供git命令行回退历史版本参考示例， 1.打开git日志 show log在项目文件夹里，右键菜单 选择”TortoiseGit” -&gt; “Show log” 2. 重置 reset选择要回退（回滚）的历史提交记录，并在那条日志记录上右键，选择 Reset &quot;$实际分支名称 actual git branch name$&quot; to this... 3. 参数 Rest type 选择 Hard在弹出的对话框内， 在 Rest type 区域选项内选择第三个参数 1Hard: Reset working tree and index (discard all local changes) 4. Push接着关闭所有对话框，重新在项目文件夹里右键，选择菜单”TortoiseGit” -&gt; “Push”选择unknown changes，在前面打勾选中，执行强制推送 force push点OK按钮 推送到远程服务器仓库 5. 查看Push推送结果看到最底部显示 Success , 即Push推送成功，git历史版本回退（回滚）操作执行成功。 6. Git命令行回退历史版本记录使用reset命令 12$ git reset --hard 464b3295HEAD is now at 464b329 added a new file 使用push命令,带参数-f来强制执行force 1234$ git push -f origin masterTotal 0 (delta 0), reused 0 (delta 0), pack-reused 0To https://xxx.com/gitlab/user/testgithubflow.git + ef1b76c...464b329 master -&gt; master (forced update) 7. 其他 Other7.1 如果master branch分支被保护，无法提交推送，要先撤销master分支的保护操作。123456$ git push -f origin masterTotal 0 (delta 0), reused 0 (delta 0), pack-reused 0remote: GitLab: You are not allowed to force push code to a protected branch on this project.To https://xxx.com/gitlab/user/testgithubflow.git ! [remote rejected] master -&gt; master (pre-receive hook declined)error: failed to push some refs to 'https://xxx.com/gitlab/user/testgithubflow.git' 7.2 如果是github且账号开启了email隐私保护（email privacy enabled），在git push操作时可能会遇到以下问题， 12345678$ git push -f origin masterTotal 0 (delta 0), reused 0 (delta 0), pack-reused 0remote: error: GH007: Your push would publish a private email address.remote: You can make your email public or disable this protection by visiting:remote: http://github.com/settings/emailsTo https://github.com/mouxie/mouxie.github.com.git ! [remote rejected] master -&gt; master (push declined due to email privacy restrictions)error: failed to push some refs to 'https://github.com/mouxie/mouxie.github.com.git' 解决办法是提供github给的替代email地址，运行下面命令(记得替代为自己的github email)： 12345$ git config --global user.email &quot;xxx123+xxxx@users.noreply.github.com&quot;$ git commit --amend --reset-author[master 13c144c] Create CNAME 1 file changed, 1 insertion(+) create mode 100644 CNAME 然后再重新push就可以正常回退历史版本了 123456789$ git push -f origin masterEnumerating objects: 4, done.Counting objects: 100% (4/4), done.Delta compression using up to 8 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 304 bytes | 304.00 KiB/s, done.Total 3 (delta 0), reused 2 (delta 0), pack-reused 0To https://github.com/mouxie/mouxie.github.com.git + 4f697eb...13c144c master -&gt; master (forced update)","link":"/git-revert-rollback-to-previous-commit.html"},{"title":"Test post from GitHub online editor and GitHub Action","text":"This article was created by github editor, and automatically deployed by GitHub Action. 测试完毕","link":"/hexo-automatically-deployed-by-GitHub-Action.html"},{"title":"Helm Charts hooks钩子让资源按照先后顺序创建，并延迟执行或暂停等待几秒再执行","text":"在使用Helm Charts部署应用到Kubernetes Cluster集群中时，可能需要等待一些依赖项先行启动起来，后续应用部署才不至于启动出错。 比如在安装时在加载其他chart之前加载配置映射或密钥。 比如部署的微服务应用需要等待数据库初始化操作成功，才可以启动时。如果这时候应用在数据库初始化还未成功完成时之前便开始执行启动操作时，大概率是会有问题发生的。 为了解决这个问题，我们需要使用到helm charts hooks钩子的权重特性来调整安排资源创建的先后启动顺序： 假设微服务 Microservice A的启动 依赖于应用B， 需要等待B先启动起来，才可以启动A。 假设A和B都定义在helm charts 应用的templates目录下的deployment.yaml里面， 我们需要给B加上hook钩子的注解 annotations，例如： 123456789apiVersion: v1kind: Podmetadata: name: &quot;{{ include &quot;mychart.fullname&quot; . }}-app-B&quot; labels: {{- include &quot;mychart.labels&quot; . | nindent 4 }} annotations: &quot;helm.sh/hook&quot;: pre-install &quot;helm.sh/hook-weight&quot;: &quot;-5&quot; 那么这时应用B就会比A先行启动，因为Ｂ会在pre-install阶段先启动,并且它的hook-weight权重指定为-5,(假如还有其他应用指定了hook-weight权重，假如hook-weight为0还有10，那么执行顺序为-5,0,10) 但是如果这时A只是间隔几秒便开始启动，并未等待B完全启动初始化成功，那么指定hook-weight权重执行顺序也没用。 这时需要在B之后，并且在A之前再加一个等待暂停的hook钩子,并指定hook-weight权重数字大于-5，小于0, 比如-4.来延迟A的启动操作。 在helm charts 应用的templates目录下创建一个新的文件，文件名为hook-sleep-20s.yaml 加入如下内容： 1234567891011121314151617apiVersion: v1kind: Podmetadata: name: &quot;{{ include &quot;mychart.fullname&quot; . }}-sleep&quot; labels: {{- include &quot;mychart.labels&quot; . | nindent 4 }} annotations: &quot;helm.sh/hook&quot;: pre-install &quot;helm.sh/hook-weight&quot;: &quot;-4&quot; &quot;helm.sh/hook-delete-policy&quot;: before-hook-creation,hook-succeededspec: containers: - name: sleep image: busybox command: ['sleep'] args: ['20'] restartPolicy: Never 利用Linux的sleep命令来延迟A的执行，暂停20秒等待B完全初始化成功启动，再来启动A. 会在启动A之前部署一个名为mychart-sleep的Kubernetes的Pod资源。它的使命就是沉睡２０秒.等待B完全初始化成功。 因为配置了hook-delete-policy删除政策，所以在等待暂停20秒后会自动删除这个钩子即kubernetes资源pod, 然后开始后续的操作。 还有另外一种方法，是使用kubernetes的initContainers或者containers lifecycle功能来实现sleep暂停， initContainers是在主容器（Pod中其他容器）启动之前运行的容器，可以用来预处理、配置、初始化容器等。你可以将需要在主容器启动之前运行的脚本放到initContainers中. lifecycle是容器的生命周期管理机制，可以用来指定容器启动和停止时需要执行的命令。你可以在lifecycle中设置postStart和preStop，从而实现延迟部署或暂停等待几秒再执行的功能。例如，你可以在postStart中设置一个等待几秒钟的sleep命令，从而实现延迟部署的功能 示例如下： 12345678910111213141516171819apiVersion: v1kind: Podmetadata: name: my-podspec: initContainers: - name: init-container image: busybox command: ['sh', '-c', 'echo &quot;Initializing container...&quot; &amp;&amp; sleep 10'] containers: - name: main-container image: nginx lifecycle: postStart: exec: command: [&quot;sh&quot;, &quot;-c&quot;, &quot;sleep 10&quot;] preStop: exec: command: [&quot;nginx&quot;, &quot;-s&quot;, &quot;quit&quot;] 使用lifecycle时，并不能完全保证会在容器的entrypoint之前被执行。","link":"/helm-chart-hooks-sleep-waiting-deploy-by-sequential.html"},{"title":"解决 root@github.com Permission denied (publickey)","text":"在日常使用git版本控制器的过程中，经常会遇到一些错误，特别是在直接使用git命令行操作，而不是使用Git图形界面（比如TortoiseGit或IDE自带的Git版本控制插件）时。例如在执行 git 命令 git pull 或者 git push 操作的时候遇到了以下错误： 12345root@github.com: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 错误原因分析从输出的output错误信息，该操作使用了root用户名去ssh登录github.com, 并提供了错误的验证登录所需要的证书。而正常应该是使用git这个用户名去登录操作。所以引起错误的原因应该是Git的配置信息缺少了git用户名。所以默认使用root这个用户名去尝试操作，才会保Permission denied的错误。那么接下来就可以按下面几种方法来解决这个 root@github.com Permission denied (publickey) 问题。 解决方法: 方法一：设置GIT_SSH_COMMAND变量 自 Git 版本2.3.0起，可以使用环境变量 GIT_SSH_COMMAND 来修改ssh的user用户名为 git,并指定登录密钥（私钥）的位置，不需要修改git config 配置文件。 1export GIT_SSH_COMMAND=&quot;ssh -i /root/.ssh/id_rsa -l git&quot; 接着就可以正常使用git pull等命令了。当然， export这个环境变量 GIT_SSH_COMMAND是临时设置，需要将其写入永久的系统环境变量中 永久设置GIT_SSH_COMMAND变量1、修改profile文件：修改文件 /etc/profile（此操作对所有用户都是有效的） 1vi /etc/profile 在里面加入以下内容: 1export GIT_SSH_COMMAND=&quot;ssh -i /root/.ssh/id_rsa -l git&quot; 保存修改后，再运行以下命令使生效： 1source /etc/profile 2、修改.bashrc文件：修改文件 ~/.bashrc（每个用户目录下都有，使用命令 ls -a ~ 查看用户目录文件列表，此操作对单独用户有效） 1vi ~/.bashrc 在里面加入以下内容： 1export GIT_SSH_COMMAND=&quot;ssh -i /root/.ssh/id_rsa -l git&quot; 保存修改后，再运行以下命令使生效： 1source ~/.bashrc 方法二：git配置core.sshCommand 自 git 版本 2.10+ (released 02/09/2016, 2016Q3) 起，也可以使用git config 设置 core.sshCommand 来指定ssh命令的内容，可以执行下面的git config命令： 1git config core.sshCommand &quot;ssh -i /root/.ssh/id_rsa -l git&quot; 接着就可以正常使用git pull等命令了。默认会写入当前使用仓库的 Git 目录中的 config 文件（即 .git/config）或者不执行上面命令，直接打开.git/config文件进行修改，在 [core] 区域加入以下内容也是可以的: 1sshCommand = &quot;ssh -i /root/.ssh/id_rsa -l git&quot; 如果需要写入全局设置或系统设置，需要加上选项 --global 或者 --system 选项，例如： 1git config --global core.sshCommand &quot;ssh -i /root/.ssh/id_rsa -l git&quot; 方法三：修改git项目远程源remote.origin.url 的值 首先查看当前git项目的配置 remote.origin.url 的值，使用以下命令找到： 1git config --show-origin remote.origin.url 假如执行输出结果显示为如下内容 1file:.git/config github.com:mouxie/mouxie.github.com.git 则可以看出在git配置文件.git/config中，配置项remote.origin.url的值在最前面缺少了用户名和@，比如：git@通过运行以下命令来修改： 1git remote set-url origin git@github.com:xxx/xxx.github.com.git 记得修改命令中xxx为真实的git repo地址。接着就可以正常使用git pull等命令了。默认会自动使用私钥文件/root/.ssh/id_rsa来操作 若需要为github指定不同的ssh登录私钥文件，则可以添加或修改服务器文件~/.ssh/config，加入以下内容 1234Host github.com Hostname github.com IdentityFile ~/.ssh/id_rsa.github IdentitiesOnly yes # see NOTES below Note: The IdentitiesOnly yes is required to prevent the SSH default behavior of sending the identity file matching the default filename for each protocol. If you have a file named ~/.ssh/id_rsa that will get tried BEFORE your ~/.ssh/id_rsa.github without this option.","link":"/fixed-root-github-com-Permission-denied-publickey.html"}],"tags":[{"name":"Ansible","slug":"Ansible","link":"/tags/Ansible/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Helm","slug":"Helm","link":"/tags/Helm/"},{"name":"Helm-charts","slug":"Helm-charts","link":"/tags/Helm-charts/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/tags/Kubernetes/"},{"name":"K8s","slug":"K8s","link":"/tags/K8s/"},{"name":"github","slug":"github","link":"/tags/github/"}],"categories":[{"name":"Ansible","slug":"Ansible","link":"/categories/Ansible/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/categories/Kubernetes/"}],"pages":[]}